# Ch-05

## 类，超类，子类

`is-a` 关系是继承的特征


#### 定义子类

```java
public class Manager extends Employee
{
}
```

`Employee` 被称为 `superclass` , `parent class` 或 `base class`。

子类要比父类功能更多。


#### 覆盖方法

```java
public class Manager extends Employee
{
    public double getSalary()
    {
    }
}
```

`Manager` 类不能访问 `Employee` 里的私有变量 `salary`，因此可以：

```java
public double getSalary()
{
    double baseSalary = super.getSalary();
    return baseSalary + bonus;
}
```

`super` 可以用来调用父类中的方法，但是 `super` 并不是一个对象的引用，不能赋值其他对象给 `super`，`super` 只是一个特殊的关键字，用来命令编译器调用父类的方法。


#### 子类构造器

```java
public Manager(String name, double salary, int year, int month, int day)
{
    super(name, salary, year, month, day);
    bonus = 0;
}
```

在这里，`super` 又另外的意义，意思是使用那些参数调用 `Employee` 的 constructor.

如果子类没有显式调用父类的 constructor，父类的没有参数的 constructor 会被调用，如果父类没有这个 constructor，编译器会报错。

```java
Manager boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
boss.setBonus(5000);

Employee[] staff = new Employee[3];
staff[0] = boss;
staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
staff[2] = new Employee("Tony Tester", 40000, 1990, 3, 15);

for (Employee e : staff)
    System.out.println(e.getName() + " " + e.getSalary();
```

`e.getSalary` 会调用到正确的方法，声明的 e 的类型是 `Employee`，但实际类型是 `Manager`，`getSalary` 的调用会使用 `Manager` 类里的 `getSalary` 方法。Java 虚拟机知道 `e` 实际指向的对象的类型，因此可以调用正确的方法。

这种对象的变量可以指向多个实际的类型被称为 `polymorphism` （多态），在运行时自动选择适当的方法称为 `dynamic binding`。


#### 继承层级

![](https://d2mxuefqeaa7sj.cloudfront.net/s_671ACDC6753147C1251D878A66070C67F33A653E05AA17A8EEBC3D888AE9FFF2_1537149777673_file.png)


#### Polymorphism

```java
Employee e;
e = new Employee(...);
e = new Manager(...);
```

Java 里的对象变量都是 `polymorphic`，意思是 `Employee` 类型的变量可以指向 `Employee` 类型的对象和任何 `Employee` 子类的对象。

不能把父类的引用赋值给子类的变量，比如：
```java
Manager m = staff[i];
```


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNTQ3MzQxNTFdfQ==
-->