# Ch-05

## 类，超类，子类

`is-a` 关系是继承的特征


#### 定义子类

```java
public class Manager extends Employee
{
}
```

`Employee` 被称为 `superclass` , `parent class` 或 `base class`。

子类要比父类功能更多。


#### 覆盖方法

```java
public class Manager extends Employee
{
    public double getSalary()
    {
    }
}
```

`Manager` 类不能访问 `Employee` 里的私有变量 `salary`，因此可以：

```java
public double getSalary()
{
    double baseSalary = super.getSalary();
    return baseSalary + bonus;
}
```

`super` 可以用来调用父类中的方法，但是 `super` 并不是一个对象的引用，不能赋值其他对象给 `super`，`super` 只是一个特殊的关键字，用来命令编译器调用父类的方法。


#### 子类构造器

```java
public Manager(String name, double salary, int year, int month, int day)
{
    super(name, salary, year, month, day);
    bonus = 0;
}
```

在这里，`super` 又另外的意义，意思是使用那些参数调用 `Employee` 的 constructor.

如果子类没有显式调用父类的 constructor，父类的没有参数的 constructor 会被调用，如果父类没有这个 constructor，编译器会报错。

```java
Manager boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
boss.setBonus(5000);

Employee[] staff = new Employee[3];
staff[0] = boss;
staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
staff[2] = new Employee("Tony Tester", 40000, 1990, 3, 15);

for (Employee e : staff)
    System.out.println(e.getName() + " " + e.getSalary();
```

`e.getSalary` 会调用到正确的方法，声明的 e 的类型是 `Employee`，但实际类型是 `Manager`，`getSalary` 的调用会使用 `Manager` 类里的 `getSalary` 方法。Java 虚拟机知道 `e` 实际指向的对象的类型，因此可以调用正确的方法。

这种对象的变量可以指向多个实际的类型被称为 `polymorphism` （多态），在运行时自动选择适当的方法称为 `dynamic binding`。


#### 继承层级

![](https://d2mxuefqeaa7sj.cloudfront.net/s_671ACDC6753147C1251D878A66070C67F33A653E05AA17A8EEBC3D888AE9FFF2_1537149777673_file.png)


#### Polymorphism

```java
Employee e;
e = new Employee(...);
e = new Manager(...);
```

Java 里的对象变量都是 `polymorphic`，意思是 `Employee` 类型的变量可以指向 `Employee` 类型的对象和任何 `Employee` 子类的对象。

不能把父类的引用赋值给子类的变量，比如：
```java
Manager m = staff[i];
```


#### 理解方法调用

比如调用 `x.f(args)` x 是 C 类的对象：

1. 编译器查看对象的声明类型和方法名，可能存在多个同名，但是参数类型不同的方法。编译器枚举出所有 C 类中名为 `f` 的方法和 C 的父类中名为 `f 的可访问方法。这时候编译器已经知道所有可能被调用的方法了。
2. 编译器确定提供给方法的参数类型，如果只有一个方法匹配，调用这个方法。这个过程被称为 `overloading resolution`。如果没有找到对应参数类型的方法或者找到多个方法，编译器报错。此时编译器已经知道方法的名称和参数类型。
3. 如果方法是 `private`, `static`, `final` 的，或者是 `constructor`，这称为 `static binding`。否则，方法的调用依赖与隐式参数的实际类型，`dynamic binding` 必须在运行时使用。
4. 程序运行并使用 `dynamic binding` 调用方法时，虚拟机必须调用适合变量指向的对象的实际类型的方法。这样每次搜索方法会比较耗时，虚拟机会给每个类计算一个 `method table`，列出所有的 `method signature` h和实际的要被调用的方法。当方法被调用时，虚拟机会做一个简单的表查找。

在运行时，调用 `e.getSalary()` 会依次发生：

1. 虚拟机获取 `e` 的实际类型的 `method table`
2. 查出找类里的 `getSalary()` 方法的 `signature`，得到要调用的方法
3. 调用方法

需要注意的：

1. 返回类型不是 `signature` 的一部分，但是当覆盖方法的时候，要保持返回类型兼容。但是可以返回子类类型，比如本来返回 `Employee` 类型，覆盖的方法可以返回 `Manager` 类型，这些方法被称为又 `covariant` 的返回类型
2. 覆盖方法时，方法的可见性至少要与父类的方法一样



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg0Nzk4ODU4NF19
-->